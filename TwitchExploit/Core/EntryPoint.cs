// --------------------------------------------------------------------------------------------------------------------
// <copyright file="EntryPoint.cs" company="TwitchExploit">
//     Copyright (c) TwitchExploit. All rights reserved.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------
namespace TwitchExploit.Core
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.Composition;
    using System.ComponentModel.Composition.Hosting;
    using System.ComponentModel.Composition.Primitives;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Security.Permissions;
    using System.Threading;
    using System.Threading.Tasks;

    using LeagueSharp;
    using LeagueSharp.SDK;

    using PlaySharp.Toolkit.EventAggregator;

    public class EntryPoint
    {
        private static AsyncMessagePump pump = new AsyncMessagePump();

        public static void Main(string[] args)
        {
            // Bootstrapper.Instance.Initialize();
            Game.OnUpdate += OnUpdate;
        }

        private static void OnUpdate(EventArgs args)
        {
            Console.WriteLine($"{ObjectManager.Player.Deaths}");
        }
    }

    public static class ThreadAwareConsole
    {
        public static void WriteLine(string format, params object[] args)
        {
            Console.WriteLine("[" + Thread.CurrentThread.ManagedThreadId + "] " + string.Format(format, args));
        }
    }

    public class AsyncMessagePump
    {
        [ThreadStatic]
        private static AsyncMessagePump current = null;

        private LinkedList<PulseAwaiter> awaiters;

        private SingleThreadSynchronizationContext context;

        public AsyncMessagePump()
        {
            this.awaiters = new LinkedList<PulseAwaiter>();
            this.context = new SingleThreadSynchronizationContext();
        }

        public static AsyncMessagePump Current => current;

        public void Execute(Action action)
        {
            if (action == null)
            {
                throw new ArgumentNullException(nameof(action));
            }

            var synchronizer = Current;

            try
            {
                current = this;

                try
                {
                    SynchronizationContext.SetSynchronizationContext(this.context);
                    action();
                }
                finally
                {
                    SynchronizationContext.SetSynchronizationContext(this.context);
                }
            }
            finally
            {
                current = synchronizer;
            }
        }

        public void Process()
        {
            this.Execute(
                () =>
                    {
                        // check all pending awaiters
                        var node = this.awaiters.Last;

                        while (node != null)
                        {
                            var nextNode = node.Previous;
                            var completed = node.Value.CheckCompletition();

                            if (completed)
                            {
                                node.List.Remove(node);
                            }

                            node = nextNode;
                        }

                        // run continuations
                        this.context.Run();
                    });
        }

        public void Register(PulseAwaiter awaiter)
        {
            this.awaiters.AddLast(awaiter);
        }
    }

    public class SingleThreadSynchronizationContext : SynchronizationContext
    {
        private Queue<Tuple<SendOrPostCallback, object>> m_nextQueue;

        private Queue<Tuple<SendOrPostCallback, object>> m_queue;

        public SingleThreadSynchronizationContext()
        {
            this.m_queue = new Queue<Tuple<SendOrPostCallback, object>>();
            this.m_nextQueue = new Queue<Tuple<SendOrPostCallback, object>>();
        }

        public override void Post(SendOrPostCallback callback, object state)
        {
            if (callback == null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            this.m_queue.Enqueue(new Tuple<SendOrPostCallback, object>(callback, state));
        }

        public void Run()
        {
            var tmp = this.m_nextQueue;
            this.m_nextQueue = this.m_queue;
            this.m_queue = tmp;

            while (this.m_nextQueue.Count > 0)
            {
                var item = this.m_nextQueue.Dequeue();

                item.Item1(item.Item2);
            }
        }

        public override void Send(SendOrPostCallback callback, object state)
        {
            throw new NotSupportedException("Synchronous operations are not supported.");
        }
    }

    public class PulseAwaiter : INotifyCompletion
    {
        private Task m_continuation;

        private Func<bool> m_hasCompleted;

        public PulseAwaiter(Func<bool> hasCompleted)
        {
            if (hasCompleted == null)
            {
                throw new ArgumentNullException(nameof(hasCompleted));
            }

            this.m_hasCompleted = hasCompleted;

            AsyncMessagePump.Current.Register(this);
        }

        public bool IsCompleted { get; private set; }

        public bool CheckCompletition()
        {
            if (this.IsCompleted)
            {
                return true;
            }

            this.IsCompleted = this.m_hasCompleted();

            if (this.IsCompleted)
            {
                this.m_continuation?.Start(TaskScheduler.FromCurrentSynchronizationContext());
            }

            return this.IsCompleted;
        }

        public void GetResult()
        {
        }

        public void OnCompleted(Action continuation)
        {
            this.m_continuation = new Task(continuation);
        }
    }
}